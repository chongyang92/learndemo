package com.lchy._11基本通信模型介绍;

/**
    目标：基本通信模型的概念介绍。

    1.BIO（BLOCK）通信模式：同步阻塞式通信（Socket网络编程也就是上面的通信架构）
        --同步：  当前线程要自己进行数据的读写操作（自己去银行取钱）--每个线程维护一个客户端，专门与客户端进行通信
        --异步：  当前线程可以去做其他事情，（委托一小弟(操作系统)拿银行卡到银行取钱，然后给你）有一个socket连接(accept)管家，有了消息，就通知到相应线程去处理，
        --阻塞：  在数据没有的情况下，还是要继续等待者读。（排队等待）
        --非阻塞：在数据没有的情况下，会去做其他事情，一旦有了数据再来获取。（柜台取款，取个号，然后坐那干其他事情）
            BIO表示同步阻塞式IO，服务器实现模式为一个连接一个线程，
            即客户端有连接请求时服务端就需要启动一个线程进行处理，
            如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

    同步阻塞：亲自去银行取款，排队等待。         ------性能极差，大量线程，大量阻塞。
    同步非阻塞：亲自去银行取款，取号，等待。
    异步阻塞： 委托一个小弟(系统)，排队等待。
    异步非阻塞：委托一个小弟(系统)，取号，等待。

    2.伪异步通信：引入了线程池。      -----伪异步阻塞的
            不需要一个客户端一个线程，可以实现1个线程复用来处理很多个客户端！
            这种架构，可以避免系统的死机，因为不会出现很多线程，线程可控
            但是高并发下性能还是很差：线程数量少，数据依然是阻塞式的。数据没有来线程还是要等待（重点是等待）！

    3.NIO表示同步非阻塞IO，服务器实现模式为请求对应一个线程，      -------连接中有数据了，创建线程去读，
        即客户端发送的连接请求都会注册到多路复用器（相当于线程池）上
        多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

        ①1个人专门负责接收客户端：
        ②1个人(多路复用器)[c1, s2 ,c3 , c4, s2, c3 ,c4]  轮询所有的客户端，发来了数据才会开启线程处理
        假如c1连接有数据过来，才新建一个线程处理，
        这种架构性能还可以！  举例：斗地主游戏，同时有6万人在线，当有人在思考出什么牌，这个连接是不能断的，处理发消息的线程是可以关闭的。有消息来了才启动线程。

        同步：线程①②还是要不断的接收客户端连接，以及处理数据。
        非阻塞：如果一个管道没有数据，不需要等待，可以轮询下一个管道是否有数据！

    4.AIO表示异步非阻塞IO，服务器实现模式为一个有效请求一个线程， ------数据被底层操作系统已经读好了
        客户端的I/O请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程进行处理。
        异步：服务端线程接收到了客户端管道以后就交给底层处理它的io通信。
                自己可以做其他事情。
        非阻塞：底层也是客户端有数据才会处理，有了数据以后处理好通知服务器应用来启动线程进行处理。

    小结：
        各种模型应用场景：
        BIO适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，JDK1.4以前的唯一选择。
        NIO适用于连接数目多且连接时间比较短(消息短)（轻操作）的架构，如聊天服务器，编程复杂。
            JDK 1.4开始支持
        AIO适用于连接数目多且连接时间比较长(消息长)(重操作)的架构，如相册服务器，
            充分调用操作系统参与并发操作，编程复杂，JDK1.7开始支持

 */
public class NIODemo {
}
